MPASM 5.87  /HOME/DJ/MPLABXPROJECTS/VEEPROM-   2-24-2022  22:53:14         PAGE  1


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00001     title  "VEEPROM-PIC8 - serial EEPROM emulator for 8-pin/8-bit Microchip PIC"
                      00002 ;================================================================================
                      00003 ; File:     veeprom-pic8.asm
                      00004 ; Date:     2/19/2022
                      00005 ; Version:  0.22.02
                      00006 ; Author:   djulien@thejuliens.net, (c)2022 djulien@thejuliens.net
                      00007 ; Device:   PIC16F15313 (midrange Microchip 8-pin PIC) or equivalent running @8 MIPS
                      00008 ;
                      00009 ; Peripherals used: Timer0, Timer2, MSSP, NVM
                      00010 ; Compiler: mpasmx(v5.35), NOT pic-as; NOTE: custom build line is used for source code fixups
                      00011 ; IDE:      MPLABX v5.35 (last one to include mpasm)
                      00012 ; Description:
                      00013 ;   VEEPROM-PIC8 is a 24C256-style EEPROM emulator for 8-pin/8-bit Microchip PIC processors.
                      00014 ;   It uses LVP and flash storage to emulate EEPROM storage, but with lower capacity and endurance.
                      00015 ;   Capacity depends on the device used.  For example, a 16F15313 would give about 3KB storage.
                      00016 ;   Flash tolerates fewer write cycles than EEPROM, but software mods could compensate in future.
                      00017 ; Build instructions:
                      00018 ; 1. Open project in MPLABX
                      00019 ; 2. Edit as needed to support other devices (@line ~4200) or additional features.  In general,
                      00020 ;    adding new devices just involves renaming symbols for consistency or changing memory size.
                      00021 ; 3. Clean + build.
                      00022 ;    Use mpasmx, not pic-as.  Builds .hex file in Absolute mode.
                      00023 ;    Custom pre- and post- build steps are used to help preprocessing or declutter .LST file
                      00024 ; 4. Flash .hex to PIC.  Use PICKit2 or 3 or equivalent; PICKit2 requires PICKitPlus for newer PICs.
                      00025 ;    After initial programming, PIC can be reflashed using I2C in-circuit.
                      00026 ; Wiring:
                      00027 ;  RA0 = I2C data (open drain); use voltage shifter if VDD != 3.3V
                      00028 ;  RA1 = I2C clock (open drain); use voltage shifter if VDD != 3.3V
                      00029 ;  RA2 = debug output (1 or more WS281X pixels), comment out #define to disable
                      00030 ;  RA3 = MCLR/VPP (LVP)
                      00031 ;  RA4 - RA5 = available for custom usage
                      00032 ; Testing:
                      00033 ;  i2cdetect -l
                      00034 ;  sudo i2cdetect -y 1
                      00035 ;  i2cget -y 1 0x50 0x00  or  i2cset
                      00036 ;  i2cdump -y 1 0x50
                      00037 ;================================================================================
Message[301]: MESSAGE: (TODO: fix this ^^^ vvv @3942)
                      00053 ;    EXPAND_PUSH FALSE, @__LINE__
                      00054 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00055 
                      00056 ;//compile-time options:
                      00057 #define WANT_DEBUG; //DEV/TEST ONLY; shows status on RA2
                      00058 ;//#define WANT_ISR  10; //ISR not used; uncomment to reserve space for ISR (or jump to)
                      00059 #define FOSC_FREQ  (32 MHz); //max speed; lower speed might work
                      00060 
                      00061 ;//pin assignments:
                      00062 #define FRPANEL  RA4; //debug "front panel" display
                      00063 #define SDA1_PIN  RA0; //make I2C consistent with ICSP (defaults to RA2)
                      00064 #define SCL1_PIN  RA1; //make I2C consistent with ICSP
                      00065 #define RGB_ORDER  0x213; //R = byte[1-1], G = byte[2-1], B = byte[3-1]; default = 0x123 = RGB
                      00066 
                      00067 ;    EXPAND_POP @__LINE__
MPASM 5.87  /HOME/DJ/MPLABXPROJECTS/VEEPROM-   2-24-2022  22:53:14         PAGE  2
VEEPROM-PIC8 - serial EEPROM emulator for 8-pin/8-bit Microchip PIC

LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00068 ;    LIST_DEBUG @63
Message[301]: MESSAGE: ([INFO] COMPILED FOR DEV/DEBUG! @1609)
  80000000                M ASM_MSB EQU -2147483648
Message[301]: MESSAGE: ([TODO]: need to UNLIT WREG_TRACKER when used in arith (else upper bits might be affected) @2398)
0000                      M init_0:
0000                      M     ORG RESET_VECTOR_
0000   0000               M     nop
0001                      M _46jump_placeholder:
0001                      M init_1:
                      01486 ;    EXPAND_DEBUG @1486
                      01487     iopin_init;
                      01488 ;    EXPAND_DEBUG @1488
                      01489     fosc_init;
0001   0151               M     banksel OSCCON3
                          M     withbit_7 bcf OSCCON3
0002   138F               M     bcf OSCCON3, 7
0003   3060               M     movlw (((ASM_MSB | (b'110' << NOSC0 | 0 << NDIV0))) & ~ASM_MSB)
0004   008D               M     movwf OSCCON1
0005   3006               M     movlw (((ASM_MSB | (HFFRQ_32000000))) & ~ASM_MSB)
0006   0093               M     movwf OSCFRQ
                      01490 ;    EXPAND_DEBUG @1490
                      01491     pmd_init; turn off unused peripherals
                          M ;    exitm; @1322
0007   307B               M     movlw (((ASM_MSB | (0xFF ^ (1 << (SYSCMD)) ^ (1 << (NVMMD))))) & ~ASM_MSB)
0008   014F               M     banksel PMD0
0009   0096               M     movwf PMD0
Message[301]: MESSAGE: (^^vv disable until needed? @1344)
000A   30F8               M     movlw (((ASM_MSB | (0xFF ^ (1 << (TMR2MD)) ^ (1 << (TMR1MD)) ^ (1 << (TMR0MD))))) & ~ASM_MSB)
000B   0097               M     movwf PMD1
000C   30FF               M     movlw (((ASM_MSB | (0xFF))) & ~ASM_MSB)
000D   0098               M     movwf PMD2
000E   0099               M     movwf PMD3
000F   009A               M     movwf PMD4
0010   009B               M     movwf PMD5
0011                      M _314jump_placeholder:
Message[301]: MESSAGE: ([TODO] use RSTOSC HFINT 1MHz? @1538)
Message[301]: MESSAGE: ([TODO] boot loader + LVP? @1557)
8007   178C           01569     __config _CONFIG1, 6028; @1569
8008   2FFE           01570     __config _CONFIG2, 12286; @1570
8009   3F9F           01571     __config _CONFIG3, 16287; @1571
800A   1FFF           01572     __config _CONFIG4, 8191; @1572
800B   3FFF           01573     __config _CONFIG5, 16383; @1573
Message[301]: MESSAGE: ([TODO] change this to use postscaler 1..16 instead of just powers of 2 (for more accuracy) @721)
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time @1967
  00000070                M         BITVARS0 ; @1968
                          M     ENDC  ;can't span macros
  0001                    M     CONSTANT BITVARS00size = LATEST_RAM1 - BITVARS0
0011                      M init_2:
0011   01F0               M     clrf BITVARS0
0012                      M _374jump_placeholder:
  0000                    M     CONSTANT load_immediate = BITDCL_COUNT
                          M lodi24: DROP_CONTEXT
0014   014F               M     banksel PMD0
                          M     withbit_2 bcf PMD0
0015   1116               M     bcf PMD0, 2
0016   017F               M     banksel TOS
                          M     withdest_0 movf TOS
0017   086E               M     movf TOS, W;
0018   0150               M     banksel NVMADR
0019   009A               M     movwf NVMADR
001A   017F               M     banksel TOS0hi
                          M     withdest_0 movf TOS0hi
001B   086F               M     movf TOS0hi, W;
001C   0150               M     banksel NVMADR0hi
001D   009B               M     movwf NVMADR0hi
                          M     withbit_7 bsf BITVARS0
001E   17F0               M     bsf BITVARS0, 7
                          M lodn24: DROP_CONTEXT
001F   313F               M     addfsr FSR0, -1
0020   0150               M     banksel NVMCON1
                          M     withbit_6 bcf NVMCON1
0021   131E               M     bcf NVMCON1, 6
0022                      M geti24_loop:
                          M     withbit_0 bsf NVMCON1
0022   141E               M     bsf NVMCON1, 0;
                          M     withdest_0 swapf NVMDAT0hi
0023   0E1D               M     swapf NVMDAT0hi, W;
0024   39F0               M     andlw 0xF0
0025   0018               M     MOVWI_fsr0_0
                          M     withdest_0 swapf NVMDAT
0026   0E1C               M     swapf NVMDAT, W;
0027   390F               M     andlw 0x0F
                          M     withdest_0 swapf NVMDAT
0029   0E1C               M     swapf NVMDAT, W;
002A   39F0               M     andlw 0xF0
002B   0018               M     MOVWI_fsr0_0
                          M     withdest_1 incfsz NVMADR
002C   0F9A               M     incfsz NVMADR, F;
                          M     withdest_1 decf NVMADR0hi
002D   039B               M     decf NVMADR0hi, F;
                          M     withdest_1 incf NVMADR0hi
002E   0A9B               M     incf NVMADR0hi, F;
                          M     withbit_0 bsf NVMCON1
002F   141E               M     bsf NVMCON1, 0;
                          M     withdest_0 movf NVMDAT0hi
0030   081D               M     movf NVMDAT0hi, W;
0031   390F               M     andlw 0x0F
                          M     withdest_0 movf NVMDAT
0033   081C               M     movf NVMDAT, W;
0034   0018               M     MOVWI_fsr0_0
                          M     withdest_1 incfsz NVMADR
0035   0F9A               M     incfsz NVMADR, F;
                          M     withdest_1 decf NVMADR0hi
0036   039B               M     decf NVMADR0hi, F;
                          M     withdest_1 incf NVMADR0hi
0037   0A9B               M     incf NVMADR0hi, F;
                          M     goto_pagesafe geti24_loop
0039   2822               M     goto geti24_loop
                          M     withbit_5 btfss NVMDAT0hi
0038   1E9D               M     btfss NVMDAT0hi, 5
                          M     EMIT return
                          M ;    EXPAND_PUSH TRUE; show expanded opc/data
003B   0008               M     return
                          M     withbit_7 btfss BITVARS0
003A   1FF0               M     btfss BITVARS0, 7
                          M     withdest_0 movf NVMADR
003C   081A               M     movf NVMADR, W;
003D   017F               M     banksel TOS
003E   00EE               M     movwf TOS
003F   0150               M     banksel NVMADR0hi
                          M     withdest_0 movf NVMADR0hi
0040   081B               M     movf NVMADR0hi, W;
0041   017F               M     banksel TOS0hi
0042   00EF               M     movwf TOS0hi
                          M     withbit_7 bcf BITVARS0
0043   13F0               M     bcf BITVARS0, 7
0044   0008               M     return
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time @1967
  00000071                M         pxbits8 ; @1968
                          M     ENDC  ;can't span macros
  0001                    M     CONSTANT pxbits80size = LATEST_RAM2 - pxbits8
Message[301]: MESSAGE: ([INFO] custom rgb order 0x213: R [1], G [0], B [2] @412)
                      00141 ;    EXPAND_PUSH FALSE, @141
                      00142 ;; custom main ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00143 
                      00144     at_init TRUE
                          M     goto_pagesafe init_3
0012   3180               M     movlp ((init_3) / 0x100)
0013   2845               M     goto init_3
0045                      M init_3:
                      00145     PinMode FRPANEL, OutLow; //set asap to prevent junk on line
0045   0140               M     banksel LATA
                          M     withbit_4 bcf LATA
0046   1218               M     bcf LATA, 4
                          M     withbit_4 bcf TRISA
0047   1212               M     bcf TRISA, 4
                      00146     at_init FALSE
0048                      M _1155jump_placeholder:
                      00147 
                      00148     THREAD_DEF front_panel, 4;
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time @1967
  00000072                M         stkptr_0 ; @1968
                          M     ENDC  ;can't span macros
  0001                    M     CONSTANT stkptr_00size = LATEST_RAM3 - stkptr_0
Message[301]: MESSAGE: (creating front_panel thread# 0 @73, stack size 4, host stack remaining: 12 @1028)
0048                      M init_4:
0048   2052               M     call stack_alloc_0
0049                      M _1161rerun_thread:
0049   2058               M     call front_panel
004A   2849               M     goto _1161rerun_thread
                          M yield_from_0: DROP_CONTEXT
004B   017F               M     banksel STKPTR
                          M     withdest_0 movf STKPTR
004C   086D               M     movf STKPTR, W;
004D   00F2               M     movwf stkptr_0
                          M yield_again_0: DROP_CONTEXT
                          M     withdest_0 movf stkptr_1
004E   0878               M     movf stkptr_1, W;
004F   017F               M     banksel STKPTR
0050   00ED               M     movwf STKPTR
0051   0008               M     return
                          M stack_alloc_0: DROP_CONTEXT
0052   017F               M     banksel STKPTR
                          M     withdest_0 movf STKPTR
0053   086D               M     movf STKPTR, W;
0054   00F2               M     movwf stkptr_0
0055   3003               M     movlw 4 - 1
                          M     withdest_1 addwf STKPTR
0056   07ED               M     addwf STKPTR, F;
0057                      M _1442jump_placeholder:
                      00149 
                      00150     BITDCL fpdirty;
  0001                    M     CONSTANT fpdirty = BITDCL_COUNT
                      00151     nbDCL24 fpcolor;
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time @1967
  00000073                M         fpcolor :3; @1968
                          M     ENDC  ;can't span macros
  0003                    M     CONSTANT fpcolor0size = LATEST_RAM4 - fpcolor
  0074                    M     CONSTANT fpcolor0mid = fpcolor + 1
  0075                    M     CONSTANT fpcolor0hi = fpcolor + 2
                      00152 
                      00153 #if 0
                      00154 fptest macro
                      00155 ;    setbit LATA, RA0, TRUE;
                      00156 ;    mov24 fpcolor, LITERAL(0x020000);
                      00157     ws1_sendpx BITWRAP(LATA, FRPANEL), LITERAL(0x020000), FIRSTPX, RESERVE(0), RESERVE(0); ; NOP 2, NOP 4; //ORG$, ORG$;
                      00158     WAIT 1 sec, YIELD, YIELD_AGAIN
                      00159 ;    setbit LATA, RA0, FALSE;
                      00160 ;    mov24 fpcolor, LITERAL(0x000200);
                      00161     ws1_sendpx BITWRAP(LATA, FRPANEL), LITERAL(0x000200), FIRSTPX, RESERVE(0), RESERVE(0); ; NOP 2, NOP 4; //ORG$, ORG$;
                      00162     WAIT 1 sec, YIELD, YIELD_AGAIN
                      00163 ;    mov24 fpcolor, LITERAL(0x000002);
                      00164     ws1_sendpx BITWRAP(LATA, FRPANEL), LITERAL(0x000002), FIRSTPX, RESERVE(0), RESERVE(0); ; NOP 2, NOP 4; //ORG$, ORG$;
                      00165     WAIT 1 sec, YIELD, YIELD_AGAIN
                      00166     ws1_sendpx BITWRAP(LATA, FRPANEL), LITERAL(0), FIRSTPX, RESERVE(0), RESERVE(0); ; NOP 2, NOP 4; //ORG$, ORG$;
                      00167     WAIT 1 sec, YIELD, YIELD_AGAIN
                      00168     endm; @168
                      00169 #endif; @169
                      00170 
                      00171 ;//show LED for 1/10 sec then turn off:
                      00172 front_panel: DROP_CONTEXT;
                      00173 ;    fptest
                      00174     whilebit BITPARENT(fpdirty), FALSE, YIELD; //wait for new data
0058                      M _1488whilebit_loop:
                          M     call_pagesafe yield
005A   204B               M     call yield
                          M     goto_pagesafe _1488whilebit_around
0059   285C               M     goto _1488whilebit_around
                          M     withbit_6 btfsc BITVARS0
0058   1B70               M     btfsc BITVARS0, 6
005B   2858               M     goto (_1488before_idler)
005C                      M _1488whilebit_around:
                      00175     setbit BITPARENT(fpdirty), FALSE;
                          M     withbit_6 bcf BITVARS0
005C   1370               M     bcf BITVARS0, 6
                      00176 ;//    ws1_sendpx BITWRAP(LATA, FRPANEL), fpcolor, FIRSTPX, RESERVE(0), RESERVE(0); NOP 2, NOP 4; //ORG$, ORG$;
                      00177     setbit LATA, FRPANEL, TRUE;
005D   0140               M     banksel LATA
                          M     withbit_4 bsf LATA
005E   1618               M     bsf LATA, 4
                      00178 ;NOTE: assumes >= 50 usec until next update, so no explicit wait 50 usec here
                      00179 ;    GOTO front_panel;
                      00180 ;    messg ^^^ remove @180
                      00181 ;    CALL sendpx;
                      00182 ;working:    GOTO front_panel;
                      00183     set_timeout 1 sec/2, YIELD; //display for 1/2 sec
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time @1967
  00000076                M         delay_count ; @1968
                          M     ENDC  ;can't span macros
  0001                    M     CONSTANT delay_count0size = LATEST_RAM5 - delay_count
005F   307B               M     movlw (((ASM_MSB | (_1659outer_count))) & ~ASM_MSB)
0060   00F6               M     movwf delay_count
Message[301]: MESSAGE: ([DEBUG] timeout 500000 "usec": "prescaler" 7+0, max intv 4096, actual 499872, rollover 254, outer 123 @761)
0061   014F               M     banksel PMD0
                          M     withbit_7 bcf PMD0
0062   1396               M     bcf PMD0, 7
                          M     withbit_2 bcf PMD1
0063   1117               M     bcf PMD1, 2
0064   3070               M     movlw (((ASM_MSB | (0 | _1659T2_prescale << T2CKPS0 | _1659T2_postscale << T2OUTPS0))) & ~ASM_MSB)
0065   0145               M     banksel T2CON
0066   008E               M     movwf T2CON
0067   30FE               M     movlw (((ASM_MSB | (_1659ROLLOVER))) & ~ASM_MSB)
0068   008D               M     movwf T2PR
0069   3001               M     movlw (((ASM_MSB | (b'001'))) & ~ASM_MSB)
006A   0090               M     movwf T2CLKCON
006B   30A8               M     movlw (((ASM_MSB | ((1 << (PSYNC)) | 0 | (1 << (T2CKSYNC)) | b'01000' << T2MODE0))) & ~ASM_MSB)
006C   008F               M     movwf T2HLT
006D   018C               M     clrf TMR2
                          M _1659delay_loop: DROP_CONTEXT
006E   0145               M     banksel T2CON
                          M     withbit_7 bsf T2CON
006F   178E               M     bsf T2CON, 7
0070   014E               M     banksel PIR4
                          M     withbit_1 bcf PIR4
0071   1090               M     bcf PIR4, 1;
0072                      M _1945whilebit_loop:
                          M     call_pagesafe yield
0074   204B               M     call yield
0075   014E               M     banksel PIR4
                          M     goto_pagesafe _1945whilebit_around
0073   2877               M     goto _1945whilebit_around
                          M     withbit_1 btfsc PIR4
0072   1890               M     btfsc PIR4, 1;
0076   2872               M     goto (_1945whilebit_loop)
0077                      M _1945whilebit_around:
                          M     withdest_1 decfsz delay_count
0077   0BF6               M     decfsz delay_count, F;
0078   286E               M     goto _1659delay_loop
                          M             exitm; @807
                      00184 ;    GOTO front_panel;
                      00185 ;    whilebit is_timeout FALSE, ORG$+3
                      00186 ;        CONTEXT_RESTORE before_whilebit
                      00187 ;        ifbit BITPARENT(fpdirty), TRUE, GOTO front_panel;
                      00188 ;       YIELD;
                      00189 ;        CONTEXT_RESTORE after_whilebit
                      00190 ;    whilebit is_timeout FALSE, ORG$;
                      00191 ;    ws1_sendpx BITWRAP(LATA, FRPANEL), LITERAL(0), FIRSTPX, RESERVE(0), RESERVE(0); NOP 2, NOP 4; //ORG$, ORG$; //clear display
                      00192     setbit LATA, FRPANEL, FALSE;
0079   0140               M     banksel LATA
                          M     withbit_4 bcf LATA
007A   1218               M     bcf LATA, 4
                      00193 ;    mov24 fpcolor, LITERAL(0);
                      00194 ;    CALL sendpx;
                      00195     set_timeout 50 usec, YIELD;
Message[301]: MESSAGE: ([DEBUG] timeout 50 "usec": "prescaler" 3+0, max intv 256, actual 50, rollover 50, outer 1 @761)
007B   3030               M     movlw (((ASM_MSB | (0 | _2139T2_prescale << T2CKPS0 | _2139T2_postscale << T2OUTPS0))) & ~ASM_MSB)
007C   0145               M     banksel T2CON
007D   008E               M     movwf T2CON
007E   3032               M     movlw (((ASM_MSB | (_2139ROLLOVER))) & ~ASM_MSB)
007F   008D               M     movwf T2PR
0080   018C               M     clrf TMR2
                          M _2139delay_loop: DROP_CONTEXT
0081   0145               M     banksel T2CON
                          M     withbit_7 bsf T2CON
0082   178E               M     bsf T2CON, 7
0083   014E               M     banksel PIR4
                          M     withbit_1 bcf PIR4
0084   1090               M     bcf PIR4, 1;
0085                      M _2284whilebit_loop:
                          M     call_pagesafe yield
0087   204B               M     call yield
0088   014E               M     banksel PIR4
                          M     goto_pagesafe _2284whilebit_around
0086   288A               M     goto _2284whilebit_around
                          M     withbit_1 btfsc PIR4
0085   1890               M     btfsc PIR4, 1;
0089   2885               M     goto (_2284whilebit_loop)
008A                      M _2284whilebit_around:
                          M             exitm; @807
                      00196     GOTO front_panel;
008A   2858               M     goto front_panel
                      00197 ;sendpx: DROP_CONTEXT;
                      00198 ;    ws1_sendpx BITWRAP(LATA, FRPANEL), fpcolor, ORG$-1, ORG$, ORG$;
                      00199 ;    return;
                      00200     
                      00201     THREAD_END;
                      00202 
                      00203 
                      00204 ;    nbDCL8 eepromAddress;
                      00205     BITDCL is_addr; //initialized to 0
  0002                    M     CONSTANT is_addr = BITDCL_COUNT
                      00206     nbDCL8 i2c_data; //non-banked to reduce bank switching during i2c processing
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time @1967
  00000077                M         i2c_data ; @1968
                          M     ENDC  ;can't span macros
  0001                    M     CONSTANT i2c_data0size = LATEST_RAM6 - i2c_data
                      00207     b0DCL veepbuf, :16; //NOTE: addressing is simpler if this is placed @start of bank 0
                          M     CBLOCK NEXT_RAM0; BOOL2INT(banked))  ;continue where we left off last time @1967
  00000020                M         veepbuf :16; @1968
                          M     ENDC  ;can't span macros
  0010                    M     CONSTANT veepbuf0size = LATEST_RAM7 - veepbuf
                      00208     
                      00209     at_init TRUE;
                          M     goto_pagesafe init_5
0057   288B               M     goto init_5
008B                      M init_5:
                      00210 ;    mov24 fpcolor, LITERAL(0);
                      00211 ;    PinMode SDA1_PIN, OutOpenDrain;
                      00212 ;    PinMode SCL1_PIN, OutOpenDrain;
                      00213     i2c_init LITERAL(0x50); ; FPP looks for capes/hats @0x50
008B   014F               M     banksel PMD4
                          M     withbit_4 bcf PMD4
008C   121A               M     bcf PMD4, 4
Message[301]: MESSAGE: ([INFO] SDA1 remapped from RA2 to RA0 @913)
008D   017D               M     banksel SSP1DATPPS
008E   01C6               M     clrf SSP1DATPPS
008F   3016               M     movlw (((ASM_MSB | (0x16))) & ~ASM_MSB)
0090   017E               M     banksel RA0PPS
0091   0090               M     movwf RA0PPS
                          M     PinMode RA0, InDigital
                          M     withbit_0 bcf ANSELA
0092   1038               M     bcf ANSELA, 0;
                          M     withbit_0 bcf WPUA
0093   1039               M     bcf WPUA, 0;
0094   0140               M     banksel TRISA
                          M     withbit_0 bsf TRISA
0095   1412               M     bsf TRISA, 0;
                          M     PinMode RA1, InDigital
0096   017E               M     banksel ANSELA
                          M     withbit_1 bcf ANSELA
0097   10B8               M     bcf ANSELA, 1;
                          M     withbit_1 bcf WPUA
0098   10B9               M     bcf WPUA, 1;
0099   0140               M     banksel TRISA
                          M     withbit_1 bsf TRISA
009A   1492               M     bsf TRISA, 1;
009B   3006               M     movlw (((ASM_MSB | (0 | 0 | b'0110' << SSPM0))) & ~ASM_MSB)
009C   0143               M     banksel SSP1CON1
009D   0090               M     movwf SSP1CON1
009E   3080               M     movlw (((ASM_MSB | ((1 << (SMP)) | 0))) & ~ASM_MSB)
009F   008F               M     movwf SSP1STAT
00A0   0191               M     clrf SSP1CON2
00A1   0192               M     clrf SSP1CON3
00A2   30FE               M     movlw (((ASM_MSB | (0x7F << 1))) & ~ASM_MSB)
00A3   008E               M     movwf SSP1MSK
                          M     mov8 SSP1ADD, (ASM_MSB | (0x50))
00A4   3050               M     movlw (((ASM_MSB | (0x50))) & ~ASM_MSB)
00A5   008D               M     movwf SSP1ADD
                          M     withdest_1 lslf SSP1ADD
00A6   358D               M     lslf SSP1ADD, F;
00A7   014E               M     banksel PIR3
                          M     withbit_0 bcf PIR3
00A8   100F               M     bcf PIR3, 0;
00A9   0143               M     banksel SSP1CON1
                          M     withbit_5 bsf SSP1CON1
00AA   1690               M     bsf SSP1CON1, 5
                      00214 ;    mov8 eepromAddress, LITERAL(0);
                      00215     LDI veepbuf;
00AB   0184               M     clrf FSR0
00AC   3020               M     movlw (((ASM_MSB | (_2984SRC >> 8 & 0xFF))) & ~ASM_MSB)
00AD   0085               M     movwf FSR00hi
00AE   2014               M     call lodi24
00AF   0012 0345 0678 00216     DW 0x012, 0x345, 0x678, 0x9ab, 0xcde, 0xf00;
       09AB 0CDE 0F00 
00B5   055A 0A55 0AA5 00217     DW 0x55A, 0xA55, 0xAA5, 0x5AA | LDI_EOF;
       25AA 
                      00218 ;//    mov8 slaveWriteType, LITERAL(SLAVE_NORMAL_DATA);
                      00219     mov16 FSR0, LITERAL(LINEAR(veepbuf)); ; //CAUTION: LDI uses FSR0/1
00B9   0184               M     clrf FSR0
00BA   3020               M     movlw (((ASM_MSB | (_3062SRC >> 8 & 0xFF))) & ~ASM_MSB)
00BB   0085               M     movwf FSR00hi
                      00220     at_init FALSE;
00BC                      M _3112jump_placeholder:
                      00221 
                      00222     THREAD_DEF veeprom, 6; 4 levels
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time @1967
  00000078                M         stkptr_1 ; @1968
                          M     ENDC  ;can't span macros
  0001                    M     CONSTANT stkptr_10size = LATEST_RAM8 - stkptr_1
Message[301]: MESSAGE: (creating veeprom thread# 1 @189, stack size 6, host stack remaining: 6 @1028)
00BC                      M init_6:
00BC   20C6               M     call stack_alloc_1
00BD                      M _3118rerun_thread:
00BD   20CF               M     call veeprom
00BE   28BD               M     goto _3118rerun_thread
                          M yield_from_1: DROP_CONTEXT
00BF   017F               M     banksel STKPTR
                          M     withdest_0 movf STKPTR
00C0   086D               M     movf STKPTR, W;
00C1   00F8               M     movwf stkptr_1
                          M yield_again_1: DROP_CONTEXT
                          M     withdest_0 movf stkptr_2
00C2   0872               M     movf stkptr_2, W;
00C3   017F               M     banksel STKPTR
00C4   00ED               M     movwf STKPTR
00C5   0008               M     return
                          M stack_alloc_1: DROP_CONTEXT
00C6   017F               M     banksel STKPTR
                          M     withdest_0 movf STKPTR
00C7   086D               M     movf STKPTR, W;
00C8   00F8               M     movwf stkptr_1
00C9   3005               M     movlw 6 - 1
                          M     withdest_1 addwf STKPTR
00CA   07ED               M     addwf STKPTR, F;
00CB                      M _3399jump_placeholder:
                      00223 
                      00224 #if 0
                      00225 test macro
                      00226     mov24 fpcolor, LITERAL(0x020000);;
                      00227     setbit BITPARENT(fpdirty), TRUE;
                      00228 ;    ws1_sendpx BITWRAP(LATA, FRPANEL), fpcolor, ORG$-1, ORG$, ORG$;
                      00229 ;    WAIT 4 sec;
                      00230 ;    fps_init 4 sec;
                      00231 ;    WAIT 4 sec, YIELD, YIELD_AGAIN;
                      00232     CALL wait4sec;
                      00233 ;    wait4frame YIELD, YIELD_AGAIN;
                      00234     mov24 fpcolor, LITERAL(0x000200);;
                      00235     setbit BITPARENT(fpdirty), TRUE;
                      00236 ;    ws1_sendpx BITWRAP(LATA, FRPANEL), fpcolor, ORG$-1, ORG$, ORG$;
                      00237 ;    WAIT 4 sec, YIELD, YIELD_AGAIN;
                      00238     CALL wait4sec;
                      00239 ;    wait4frame YIELD, YIELD_AGAIN;
                      00240     mov24 fpcolor, LITERAL(0x000002);;
                      00241     setbit BITPARENT(fpdirty), TRUE;
                      00242 ;    ws1_sendpx BITWRAP(LATA, FRPANEL), fpcolor, ORG$-1, ORG$, ORG$;
                      00243 ;    WAIT 4 sec, YIELD, YIELD_AGAIN;
                      00244     CALL wait4sec;
                      00245     GOTO veeprom;
                      00246 ;    wait4frame YIELD, YIELD_AGAIN;
                      00247     mov24 fpcolor, LITERAL(0);;
                      00248     setbit BITPARENT(fpdirty), TRUE;
                      00249 ;    ws1_sendpx BITWRAP(LATA, FRPANEL), fpcolor, ORG$-1, ORG$, ORG$;
                      00250 ;    WAIT 4 sec, YIELD, YIELD_AGAIN;
                      00251     CALL wait4sec;
                      00252 ;    wait4frame YIELD, YIELD_AGAIN;
                      00253     GOTO veeprom;
                      00254     endm; @254
                      00255 
                      00256 wait4sec: DROP_CONTEXT;
                      00257     WAIT 4 sec/4, YIELD, YIELD_AGAIN; RESERVE(0), RESERVE(0); busy wait
                      00258 ;    set_timeout 1 sec/2, NOP 1; RESERVE(0); YIELD; //display for 1/2 sec
                      00259     RETURN;
                      00260 #endif
                      00261 
                      00262 
                      00263 i2c_wrdone: DROP_CONTEXT;
                      00264     setbit BITPARENT(is_addr), FALSE;
                          M     withbit_5 bcf BITVARS0
00CC   12F0               M     bcf BITVARS0, 5
                      00265 i2c_done: DROP_CONTEXT;
                      00266     setbit SSP1CON1, CKP, TRUE; // release SCL
00CD   0143               M     banksel SSP1CON1
                          M     withbit_4 bsf SSP1CON1
00CE   1610               M     bsf SSP1CON1, 4
                      00267 ;    setbit LATA, FRPANEL, FALSE;
                      00268 veeprom: DROP_CONTEXT;
                      00269 ;//    test
                      00270     wait4i2c YIELD, YIELD_AGAIN; //NO-nothing else to do so just busy-wait
00CF   20BF               M     call yield
00D0   014E               M     banksel PIR3
                          M     goto_pagesafe yield_again
00D2   28C2               M     goto yield_again
                          M     withbit_0 btfss PIR3
00D1   1C0F               M     btfss PIR3, 0;
                          M     withbit_0 bcf PIR3
00D3   100F               M     bcf PIR3, 0;
                      00271     mov8 i2c_data, SSP1BUF; //read SSPBUF to clear BF
00D4   0143               M     banksel SSP1BUF
                          M     withdest_0 movf SSP1BUF
00D5   080C               M     movf SSP1BUF, W;
00D6   00F7               M     movwf i2c_data
                      00272 ;    setbit LATA, FRPANEL, TRUE;
                      00273 ;    mov24 fpcolor, LITERAL(0);
                      00274     setbit BITPARENT(fpdirty), TRUE;
                          M     withbit_6 bsf BITVARS0
00D7   1770               M     bsf BITVARS0, 6
                      00275     ifbit SSP1STAT, R_NOT_W, TRUE, GOTO i2c_read
                          M     goto_pagesafe i2c_read
00D9   28F9               M     goto i2c_read
                          M     withbit_2 btfsc SSP1STAT
00D8   190F               M     btfsc SSP1STAT, 2
                      00276     ifbit SSP1STAT, D_NOT_A, TRUE, GOTO i2c_write
                          M     goto_pagesafe i2c_write
00DB   28DE               M     goto i2c_write
                          M     withbit_5 btfsc SSP1STAT
00DA   1A8F               M     btfsc SSP1STAT, 5
                      00277 ;//prepare to receive data from the master
                      00278 ;//    I2C1_StatusCallback(I2C1_SLAVE_WRITE_REQUEST);
                      00279 ;// master will send eeprom address next
                      00280 ;//    mov8 slaveWriteType, LITERAL(SLAVE_DATA_ADDRESS);
                      00281     setbit BITPARENT(is_addr), TRUE;
                          M     withbit_5 bsf BITVARS0
00DC   16F0               M     bsf BITVARS0, 5
                      00282     GOTO i2c_done;
00DD   28CD               M     goto i2c_done
00DE                  00283 i2c_write:
                      00284 ;    I2C1_slaveWriteData = i2c_data;
                      00285 ;//process I2C1_slaveWriteData from the master
                      00286 ;//    I2C1_StatusCallback(I2C1_SLAVE_WRITE_COMPLETED);
                      00287     ifbit BITPARENT(is_addr), TRUE, GOTO i2c_write_addr;
                          M     goto_pagesafe i2c_write_addr
00DF   28EE               M     goto i2c_write_addr
                          M     withbit_5 btfsc BITVARS0
00DE   1AF0               M     btfsc BITVARS0, 5
                      00288 ;// master has written data to store in the eeprom
                      00289     mov8 INDF0_postinc, i2c_data;
                          M     withdest_0 movf i2c_data
00E0   0877               M     movf i2c_data, W;
00E1   001A               M     MOVWI_fsr0_2
                      00290     cmp16 FSR0, LITERAL(LINEAR(veepbuf + SIZEOF(veepbuf)));;
00E2   3020               M     movlw ((((ASM_MSB | (((-2147475440) >> (8 * (1))) & 0xFF)))) & ~ASM_MSB)
                          M     goto_pagesafe _3833not_eq
00E5   28E8               M     goto _3833not_eq
                          M     withbit_2 btfss STATUS
00E4   1D03               M     btfss STATUS, 2
00E6   3010               M     movlw ((((ASM_MSB | (((-2147475440) >> (8 * (0))) & 0xFF)))) & ~ASM_MSB)
00E8                      M _3833not_eq:
                      00291     ifbit BORROW TRUE, GOTO i2c_wrdone; //EQUALS0 TRUE, ADDFSR -SIZEOF(veepbuf);
                          M     goto_pagesafe i2c_wrdone
00E9   28CC               M     goto i2c_wrdone
                          M     withbit_0 btfss STATUS
00E8   1C03               M     btfss STATUS, 0;
                      00292 ;//    LED_blink(I2C1_slaveWriteData);
                      00293     mov16 FSR0, LITERAL(LINEAR(veepbuf)); ; //wrap
00EA   0184               M     clrf FSR0
00EB   3020               M     movlw (((ASM_MSB | (_3966SRC >> 8 & 0xFF))) & ~ASM_MSB)
00EC   0085               M     movwf FSR00hi
                      00294     GOTO i2c_wrdone;
00ED   28CC               M     goto i2c_wrdone
00EE                  00295 i2c_write_addr:
                      00296 ;    mov8 WREG, i2c_data;
                      00297 ;    ANDLW 0x0F;
                      00298 ;    mov8 FSR0L, WREG; //i2c_data;
                      00299     mov16 FSR0, LITERAL(LINEAR(veepbuf));;
00EE   0184               M     clrf FSR0
00EF   0085               M     movwf FSR00hi
                      00300     cmp8 i2c_data, LITERAL(SIZEOF(veepbuf));;
00F0   3010               M     movlw (((ASM_MSB | (veepbuf0size))) & ~ASM_MSB)
                      00301     ifbit BORROW FALSE, CLRF i2c_data; //wrap; ADDWF i2c_data, F; //clamp
                          M     clrf_tracker i2c_data
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK i2c_data
00F3   01F7               M     clrf i2c_data
                          M     withbit_0 btfsc STATUS
00F2   1803               M     btfsc STATUS, 0;
                      00302     add16_8 FSR0, i2c_data;
                          M     withdest_0 movf i2c_data
00F4   0877               M     movf i2c_data, W;
                          M     withdest_1 addwf FSR0
00F5   0784               M     addwf FSR0, F;
                          M     withdest_1 incf_banksafe FSR00hi
                          M     incf_banksafe FSR00hi, F;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK FSR00hi
                          M     withdest_1 incf FSR00hi
00F7   0A85               M     incf FSR00hi, F;
                          M     withbit_0 btfsc STATUS
00F6   1803               M     btfsc STATUS, 0;
                      00303     GOTO i2c_wrdone;
00F8   28CC               M     goto i2c_wrdone
00F9                  00304 i2c_read:
                      00305     ifbit SSP1STAT, D_NOT_A, FALSE, GOTO i2c_rddata;
                          M     goto_pagesafe i2c_rddata
00FA   28FE               M     goto i2c_rddata
                          M     withbit_5 btfss SSP1STAT
00F9   1E8F               M     btfss SSP1STAT, 5
                      00306     ifbit SSP1CON2, ACKSTAT, FALSE, GOTO i2c_rddata;
                          M     goto_pagesafe i2c_rddata
00FC   28FE               M     goto i2c_rddata
                          M     withbit_6 btfss SSP1CON2
00FB   1F11               M     btfss SSP1CON2, 6
                      00307 ;// perform any post-read processing
                      00308 ;//    I2C1_StatusCallback(I2C1_SLAVE_READ_COMPLETED);
                      00309     GOTO i2c_done;
00FD   28CD               M     goto i2c_done
00FE                  00310 i2c_rddata:
                      00311 ;//write data into SSPBUF
                      00312 ;//    I2C1_StatusCallback(I2C1_SLAVE_READ_REQUEST);
                      00313     mov8 SSP1BUF, INDF0_postinc;
00FE   0012               M     MOVIW_fsr0_2
00FF   008C               M     movwf SSP1BUF
                      00314     cmp16 FSR0, LITERAL(LINEAR(veepbuf + SIZEOF(veepbuf)));;
0100   3020               M     movlw ((((ASM_MSB | (((-2147475440) >> (8 * (1))) & 0xFF)))) & ~ASM_MSB)
                          M     goto_pagesafe _4368not_eq
0103   2906               M     goto _4368not_eq
                          M     withbit_2 btfss STATUS
0102   1D03               M     btfss STATUS, 2
0104   3010               M     movlw ((((ASM_MSB | (((-2147475440) >> (8 * (0))) & 0xFF)))) & ~ASM_MSB)
0106                      M _4368not_eq:
                      00315     ifbit BORROW TRUE, GOTO i2c_done; //ADDFSR -SIZEOF(veepbuf)[0];
                          M     goto_pagesafe i2c_done
0107   28CD               M     goto i2c_done
                          M     withbit_0 btfss STATUS
0106   1C03               M     btfss STATUS, 0;
                      00316     mov16 FSR0, LITERAL(LINEAR(veepbuf));;
0108   0184               M     clrf FSR0
0109   3020               M     movlw (((ASM_MSB | (_4501SRC >> 8 & 0xFF))) & ~ASM_MSB)
010A   0085               M     movwf FSR00hi
                      00317     GOTO i2c_done;
010B   28CD               M     goto i2c_done
                      00318 
                      00319     THREAD_END;
                      00320 
                      00321 ;    EXPAND_POP @321
                          M     goto_pagesafe init_7
00CB   290C               M     goto init_7
010C                      M init_7:
                          M     at_eof
                          M ;    EXPAND_PUSH FALSE, @3691
                          M ;;broken:    REPEAT EOF_COUNT, eof_#v(repeater)
                          M ;broken:    REPEAT LITERAL(EOF_COUNT), EMITL at_eof_#v(REPEATER): eof_#v(REPEATER)
                          M     WARNIF(DOING_INIT != 1, [WARNING] doing init @eof: 1              @3694); ; mismatched directives can cause incorrect code gen
  0000                    M     LOCAL count = 0;
                          M     while count < EOF_COUNT
                          M         EMITL at_eof_0:;         ; only used for debug
                          M ;    EXPAND_PUSH TRUE, @3875; show expanded opc/data
010C                      M at_eof_0:
Message[301]: MESSAGE: ([WARNING] macro expand stack not empty @eof: 2 @3786)
010C                      M at_eof_1:
Message[301]: MESSAGE: ([WARNING] list expand stack not empty @eof: 1 @3840)
010C                      M at_eof_2:
010C                      M eof:
Message[301]: MESSAGE: ([INFO] optimization stats: @4088)
010C                      M at_eof_3:
Message[301]: MESSAGE: ([INFO] bank sel: 41 (45%), dropped: 51 (55%) @1808)
010C                      M at_eof_4:
Message[301]: MESSAGE: ([INFO] bank0 used: 16/80 (20%) @1992)
Message[301]: MESSAGE: ([INFO] non-banked used: 9/16 (56%) @1998)
010C                      M at_eof_5:
010C                      M at_eof_6:
Message[301]: MESSAGE: ([INFO] page sel: 1 (3%), dropped: 38 (97%) @3396)
Message[301]: MESSAGE: ([INFO] page0 used: 268/2048 (13%) @3398)
010C                      M at_eof_7:
010C                      M at_eof_8:
Message[301]: MESSAGE: ([INFO] #threads: 2, stack alloc: 10/16 (63%) @1226)
Message[301]: MESSAGE: ([DEBUG] why is banksel needed here? 396 @1232)
                          M     withdest_0 movf stkptr_2
010C   0872               M     movf stkptr_2, W;
010D   017F               M     banksel STKPTR
010E   00ED               M     movwf STKPTR
010F   0008               M     return
  00000072                M stkptr_2 EQU stkptr_0
0110   0063               M     sleep
0111                      M _4718jump_placeholder:
MPASM 5.87  /HOME/DJ/MPLABXPROJECTS/VEEPROM-   2-24-2022  22:53:14         PAGE  3
VEEPROM-PIC8 - serial EEPROM emulator for 8-pin/8-bit Microchip PIC

SYMBOL TABLE
  LABEL                             VALUE 

ABS                               IIF((x) < 0, -(x), x)
ADDFSR                            addfsr_wrap
ADDLW                             addlw_tracker
ADDWF                             addwf_banksafe
ALIAS_DCL24                       
ALLOC_GPR                         
ANDLW                             andlw_tracker
ASM_MSB                           80000000
BANKCHK                           
BANKLEN                           0x80
BANKOF                            IIF(ISBANKED(reg), REG2ADDR(reg) / BANKLEN, BANK_UNKN)
BANKOFS                           ((reg) % BANKLEN)
BANKSAFE                          
BANKSEL_DROP                      00000033
BANKSEL_KEEP                      0000002A
BANK_TRACKER                      00001FED
BANK_UNKN                         -1
BCF                               bcf_tracker
BIT                               (1 << (n))
BITDCL                            
BITDCL_COUNT                      00000003
BITOF                             ((bitwrap) & 0x0F)
BITPARENT                         BITVARS#v(name / 8), 7 - name % 8
BITVARS0                          00000070
BITVARS00size                     00000001
BITWRAP                           (((reg) << 4) | ((bitnum) & 0x0F))
BOOL2INT                          ((val) != 0)
BORROW                            STATUS, Carry, !
BSF                               bsf_tracker
BYTEOF                            IIF(ISLIT(val), BYTEOF_LIT(val, which), BYTEOF_REG(val, which))
BYTEOF_LIT                        LITERAL(((val) >> (8 * (which))) & 0xFF)
BYTEOF_REG                        REGISTER((val) + (which))
CALL                              call_pagesafe
CALLIF                            
CARRY                             STATUS, Carry,
CLRF                              clrf_tracker
CLRW                              CLRF WREG
COMMON_END                        0xC
CONTEXT_ADDR                      ctx_addr_#v(name)
CONTEXT_RESTORE                   
CONTEXT_SAVE                      
CURRENT_FPS_usec                  FFFFFFFF
Carry                             00000000
DECF                              decf_banksafe
DECFSZ                            decfsz_tracker
DISABLED                          BIT(n)
DISABLED_ALL                      0xFF
DOING_INIT                        00000000
DROP_BANK                         
DROP_CONTEXT                      
DROP_WREG                         
EMIT                              
EMIT2                             
EMITL                             
ENABLED                           NOBIT(n)
ENABLED_ALL                       0
ENDOF                             (name + SIZEOF(name))
EOF_ADDR                          0000010C
EOF_COUNT                         00000009
EQUALS0                           STATUS, Equals0,
ERRIF                             ERRIF_#v(((assert) != 0))  msg
ERRIF_0                           IGNORE_EOL
ERRIF_1                           error
EXPAND_CTL                        
EXPAND_DEBUG                      messg [DEBUG] MEXPAND current #v(MEXPAND_STACK & 1), stack #v(MEXPAND_STACK), depth #v(MEXPAND_DEP
EXPAND_POP                        EXPAND_CTL -1,
EXPAND_PUSH                       EXPAND_CTL
EXPAND_RESTORE                    EXPAND_CTL 0xf00d,
Equals0                           00000002
FALSE                             0
FIRSTPX                           ORG $-1
FOSC_FREQ                         (32 MHz)
FOUND_MSB                         00000000
FRPANEL                           RA4
FSR00hi                           00000005
FSR10hi                           00000007
GOTO                              goto_pagesafe
GPR_END                           0x70
GPR_START                         0x20
HIBYTE16                          BYTEOF(val, 1)
HIBYTE24                          BYTEOF(val, 2)
HOST_STKLEN                       16-0
I2C_slave7                        b'0110'
IGNORE_EOL                        
IIF                               IIF_#v(((TF) != 0))(tval,  fval)
IIFDEBUG                          expr_true
IIF_0                             (fval)
IIF_1                             (tval)
INCF                              incf_banksafe
INCFSZ                            incfsz_tracker
INCW                              ADDLW 1
INDF0_postdec                     00020003
INDF0_postinc                     00020002
INDF0_predec                      00020001
INDF0_preinc                      00020000
INDF0_special                     00020000
INDF1_postdec                     00010003
INDF1_postinc                     00010002
INDF1_predec                      00010001
INDF1_preinc                      00010000
INDF1_special                     00010000
INIT_COUNT                        00000008
IN_THREAD                         00000000
IORLW                             iorlw_tracker
ISBANKED                          ((BANKOFS(reg) >= COMMON_END) && (BANKOFS(reg) < GPR_END))
ISLIT                             ((val) & ASM_MSB)
ISR_VECTOR                        (RESET_VECTOR + 4)
InAnalog                          00000200
InDigital                         00000100
InFlags                           00000380
KHz                               * 1000
LAST_INIT                         00000112
LATEST_RAM1                       00000071
LATEST_RAM2                       00000072
LATEST_RAM3                       00000073
LATEST_RAM4                       00000076
LATEST_RAM5                       00000077
LATEST_RAM6                       00000078
LATEST_RAM7                       00000030
LATEST_RAM8                       00000079
LDI                               
LDI_EOF                           00002000
LINEAR                            (((reg) - GPR_START) | 0x2000)
LISTCTL                           
LIST_DEBUG                        messg [DEBUG] LSTCTL current #v(LSTCTL_STACK & 1), stack #v(LSTCTL_STACK), depth #v(LSTCTL_DEPTH) 
LIST_POP                          LISTCTL -1,
LIST_PUSH                         LISTCTL
LIST_RESTORE                      LISTCTL 0xfeed,
LIT2VAL                           ((n) & ~ASM_MSB)
LITBIT                            LITERAL(BIT(n))
LITERAL                           (ASM_MSB | (n))
LITPAGEOF                         ((addr) / LIT_PAGELEN)
LIT_PAGELEN                       0x800
LOBYTE                            BYTEOF(val, 0)
LODW                              
LSLF                              lslf_banksafe
LSTCTL_DEEPEST                    00000003
LSTCTL_DEPTH                      00000000
LSTCTL_STACK                      00000000
MAX                               IIF((x) > (y), x, y)
MAX_RAM0                          00000070
MAX_RAM1                          000000F0
MAX_RAM9999                       00000080
MAX_T0POSTSC                      00000004
MAX_T0PRESCALER                   0000000F
MAX_T2PRESC                       00000007
MEXPAND_DEEPEST                   00000005
MEXPAND_DEPTH                     00000002
MEXPAND_STACK                     00000002
MHz                               * 1000000
MIDBYTE                           BYTEOF(val, 1)
MIN                               IIF((x) < (y), x, y)
MIN_STACK                         2
MIPS                              * 4 MHz
MOVF                              movf_banksafe
MOVIW_fsr0_0                      MOVIW ++FSR0
MOVIW_fsr0_1                      MOVIW --FSR0
MOVIW_fsr0_2                      MOVIW FSR0++
MOVIW_fsr0_3                      MOVIW FSR0--
MOVIW_fsr1_0                      MOVIW ++FSR1
MOVIW_fsr1_1                      MOVIW --FSR1
MOVIW_fsr1_2                      MOVIW FSR1++
MOVIW_fsr1_3                      MOVIW FSR1--
MOVIW_opc                         MOVIW_fsr#v((fsr) == FSR1)_#v((mode) & 3)
MOVLW                             movlw_tracker
MOVWF                             movwf_banksafe
MOVWI_fsr0_0                      MOVWI ++FSR0
MOVWI_fsr0_1                      MOVWI --FSR0
MOVWI_fsr0_2                      MOVWI FSR0++
MOVWI_fsr0_3                      MOVWI FSR0--
MOVWI_fsr1_0                      MOVWI ++FSR1
MOVWI_fsr1_1                      MOVWI --FSR1
MOVWI_fsr1_2                      MOVWI FSR1++
MOVWI_fsr1_3                      MOVWI FSR1--
MOVWI_opc                         MOVWI_fsr#v((fsr) == FSR1)_#v((mode) & 3)
MY_CONFIG1                        0000178C
MY_CONFIG2                        00002FFE
MY_CONFIG3                        00003F9F
MY_CONFIG4                        00001FFF
MY_CONFIG5                        00003FFF
NEEDS_BANKSEL                     (ISBANKED(regto) && (BANKOF(regto) != BANKOF(regfrom)))
NEXT_RAM0                         00000030
NEXT_RAM1                         000000A0
NEXT_RAM9999                      00000079
NOBANK                            0000270F
NOBIT                             0
NOP                               nop_multi
NOP_expanded                      00000000
NULL_STMT                         ORG $
NUM_CONTEXT                       00000039
NUM_THREADS                       00000002
NVMADR0hi                         0000081B
NVMDAT0hi                         0000081D
OutFlags                          00000007
OutHigh                           00000001
OutLow                            00000002
OutOpenDrain                      00000004
PAGECHK                           
PAGESEL_DROP                      00000026
PAGESEL_KEEP                      00000001
PAGE_TRACKER0                     00000000
PAGE_TRACKER1                     00000045
PASS1_FIXUPS                      00000000
PASS2_FIXUPS                      00000000
PLL                               * 2
POP                               
PPS_SCL1OUT                       0x15
PPS_SDA1OUT                       0x16
PUSH                              
PinMode                           
Pullup                            00000080
RAM_BLOCK                         00000008
RAM_LEN0                          00000050
RAM_LEN1                          00000050
RAM_LEN9999                       00000010
RAM_START0                        00000020
RAM_START1                        000000A0
RAM_START9999                     00000070
RAM_USED0                         00000010
RAM_USED1                         00000000
RAM_USED9999                      00000009
REG2ADDR                          (a)
REGHI                             name#v(0)hi
REGISTER                          (a)
REGLO                             name
REGMID                            name#v(0)mid
REGOF                             (((bitwrap) >> 4) & 0xFFFF)
REGPAGEOF                         ((addr) / REG_PAGELEN)
REG_PAGELEN                       0x100
REPEAT                            
REPEATER                          00000000
RERUN_THREADS                     TRUE
RESERVE                           ORG$+n
RESET_VECTOR                      0
RESET_VECTOR_                     00000000
RETURN                            EMIT return
REVBIT                            (0x80 >> (n))
RGB_BYTE                          RGB_#v(n)
RGB_ORDER                         0x213
SCL1_PIN                          RA1
SDA1_PIN                          RA0
SET8W                             IORLW 0xFF
SIZEOF                            name#v(0)size
SP1BRG0hi                         0000011C
STK_ALLOC                         0000000A
SUBLW                             sublw_tracker
SUBLWB                            
SUPPORTED                         TRUE
SWAPF                             swapf_banksafe
T0SRC_FOSC4                       b'010'
T0_prescaler                      prescaler(FOSC_FREQ/4, freq)
T2SRC_FOSC4                       b'001'
T2_oneshot                        b'01000'
T2_prescaler                      prescaler(FOSC_FREQ/4, freq)
THREAD_DEF                        
THREAD_END                        
TIMEOUT_count                     00000001
TIMEOUT_init                      00000032
TOS                               00001FEE
TOS0hi                            00001FEF
TRUE                              1
TUNED                             as_is
UGLY_PASS12FIX                    
USE_HFFRQ                         b'110'
WAIT                              
WANT_DEBUG                        
WARNIF                            WARNIF_#v(((assert) != 0))  msg
WARNIF_0                          IGNORE_EOL
WARNIF_1                          messg
WREG_TRACKER                      00000072
WREG_UNKN                         40000000
XBIT                              NOBIT(n)
XORLW                             xorlw_tracker
XORWF                             xorwf_banksafe
YESNO                             YESNO_#v(((val) != 0))
YESNO_0                           false
YESNO_1                           true
YIELD_AGAIN_inlined               
__16F15313                        00000001
add16_8                           
addfsr_wrap                       
addlw_tracker                     
addwf_banksafe                    
after_whilebit                    0000001B
andlw_tracker                     
asmbit                            00000020
asmpower2                         00000000
at_eof                            
at_init                           
b0DCL                             ALLOC_GPR 0,
b0DCL16                           
b0DCL24                           
b0DCL8                            
b1DCL                             ALLOC_GPR 1,
bcf_tracker                       
before_whilebit                   00000017
bitnum_arg                        withbit_#v(argg)
bitoff                            
bitoff_0                          
bitoff_1                          
bitoff_2                          
bitoff_3                          
bitoff_4                          
bitoff_5                          
bitoff_6                          
bitoff_7                          
biton                             
biton_0                           
biton_1                           
biton_2                           
biton_3                           
biton_4                           
biton_5                           
biton_6                           
biton_7                           
bsf_tracker                       
call_pagesafe                     
clrf_tracker                      
clrw                              clrf WREG
cmp16                             
cmp8                              
comf2s                            
dec16                             
decf_banksafe                     
decfsz_tracker                    
delay_count                       00000076
delay_count0size                  00000001
dest_arg                          withdest_#v(argg)
divup                             (((num)+(den)-1)/(den))
elapsed_fps                       PIR0, TMR0IF
eof                               0000010C
eof_0                             
eof_1                             
eof_2                             
eof_3                             
eof_4                             
eof_5                             
eof_6                             
eof_7                             
eof_8                             
find_msb                          
fosc_init                         
fpcolor                           00000073
fpcolor0hi                        00000075
fpcolor0mid                       00000074
fpcolor0size                      00000003
fpdirty                           00000001
fps_init                          
front_panel                       00000058
geti24_loop                       00000022
goto_pagesafe                     
has_WREG2                         00000000
i2c_data                          00000077
i2c_data0size                     00000001
i2c_done                          000000CD
i2c_init                          
i2c_rddata                        000000FE
i2c_read                          000000F9
i2c_wrdone                        000000CC
i2c_write                         000000DE
i2c_write_addr                    000000EE
ifbit                             
ifbit_const                       
inc16                             
incf_banksafe                     
incfsz_tracker                    
incw                              addlw 1
iopin_init                        
iorlw_tracker                     
isPASS2                           eof
is_addr                           00000002
is_timeout                        T2CON, TMR2ON, !
khz                               rdiv(freq, 1000)
load_immediate                    00000000
lodi24                            00000014
lodn24                            0000001F
log2                              LOG2_#v(n)
lslf_banksafe                     
mhz                               rdiv(freq, 1000000)
mov16                             mov_mb 16,
mov24                             mov_mb 24,
mov8                              
mov_mb                            
movf_banksafe                     
movlw_tracker                     
movwf_banksafe                    
msec                              * 1000
nbDCL                             ALLOC_GPR NOBANK,
nbDCL16                           
nbDCL24                           
nbDCL8                            
need_pagesel                      (LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER#v(((DOING_INIT) != 0))))
nop_multi                         
nopif                             
pct                               rdiv(100 * (num), den)
pmd_init                          
pps_lock                          
prescaler                         log2((base_freq) / (want_freq))
pxbits8                           00000071
pxbits80size                      00000001
rdiv                              (((num)+(den)/2)/MAX(den, 1))
scale                             (BIT(prescale) KHz / khz(freq))
sec                               * 1000000
set_timeout                       
setbit                            
showarg_0                         
stkptr_00size                     00000001
stkptr_10size                     00000001
sublw_tracker                     
swapf_banksafe                    
swapreg                           
usec                              * 1
val_arg                           showarg_#v(argg)
veepbuf                           00000020
veepbuf0size                      00000010
veeprom                           000000CF
wait4frame                        
wait4i2c                          
whilebit                          
with_arg                          witharg_#v(argg)
witharg_0                         
withbit_0                         
withbit_1                         
withbit_2                         
withbit_3                         
withbit_4                         
withbit_5                         
withbit_6                         
withbit_7                         
withdest_0                        
withdest_1                        
ws1_sendbit                       
ws1_sendbyte                      
ws1_sendpx                        
xorlw_tracker                     
xorwf_banksafe                    
yield                             000000BF
yield_again                       000000C2


MEMORY USAGE MAP ('X' = Used,  '-' = Unused)

0000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
00C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0100 : XXXXXXXXXXXXXXXX X--------------- ---------------- ----------------
8000 : -------XXXXX---- ---------------- ---------------- ----------------

All other memory blocks unused.

Program Memory Words Used:   278
Program Memory Words Free:  1770


Errors   :     0
Warnings :     0 reported,     0 suppressed
Messages :    23 reported,    83 suppressed


