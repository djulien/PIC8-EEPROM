MPASM 5.87  /HOME/DJ/MPLABXPROJECTS/VEEPROM-   2-19-2022  14:32:14         PAGE  1


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00001     title  "PIC8-EEPROM - serial EEPROM emulator for 8-pin/8-bit Microchip PIC"
                      00002 ;add support for other devices @line ~4200
                      00003 ;in general, adding support just involves renaming items to have consistent names or changing mem size
                      00004 ;custom build step:
                      00005 ;pre: cat *.asm  |  awk '{gsub(/__LINE__/, NR)}1' |  tee  "__FILE__ 1.ASM"  "__FILE__ 2.ASM"  "__FILE__ 
                            3.ASM"  "__FILE__ 4.ASM"  "__FILE__ 5.ASM"  "__FILE__ 6.ASM"  "__FILE__ 7.ASM"  >  __FILE__.ASM
                      00006 ;post: rm -f nope__FILE__* &amp;&amp; cp ${ImagePath} ~/Documents/ESOL-fog/ESOL21/tools/PIC/firmware &am
                            p;&amp;  awk 'BEGIN{IGNORECASE=1} NR==FNR { if ($$2 == "EQU") EQU[$$1] = $$3; next; } !/^ +((M|[
                      00007 ;================================================================================
                      00008 ; File:     pic8-eeprom.asm
                      00009 ; Date:     2/19/2022
                      00010 ; Version:  0.22.02
                      00011 ; Author:   djulien@thejuliens.net, (c)2022 djulien@thejuliens.net
                      00012 ; Device:   PIC16F15313 (midrange Microchip 8-pin PIC) or equivalent running @8 MIPS
                      00013 
                      00014 ; Peripherals used: Timer0, Timer1 (gated), Timer2, no-MSSP, EUSART, no-PWM, CLC
                      00015 ; Compiler: mpasmx(v5.35), NOT pic-as; NOTE: custom build line is used for source code fixups
                      00016 ; IDE:      MPLABX v5.35 (last one to include mpasm)
                      00017 ; Description:
                      00018 ;   WS281X-Splitter can be used for the following purposes:
                      00019 ;   1. split a single WS281X data stream into <= 4 separate segments; 
                      00020 ;     creates a virtual daisy chain of LED strings instead of using null pixels between
                      00021 ;   2. debugger or signal integrity checker; show 24-bit WS pixel data at end of string
                      00022 ;   3. timing checker; display frame rate (FPS received); alternating color is used as heartbeat
                      00023 ; Build instructions:
                      00024 ;no   ?Add this line in the project properties box, pic-as Global Options -> Additional options:
                      00025 ;no   -Wa,-a -Wl,-pPor_Vec=0h,-pIsr_Vec=4h
                      00026 ;   - use PICKit2 or 3 or equivalent programmer (PICKit2 requires PICKitPlus for newer PICs)
                      00027 ; Wiring:
                      00028 ;  RA0 = debug output (32 px WS281X):
                      00029 ;        - first 24 px shows segment 1/2/3 quad px length (0 = 1K)
                      00030 ;        - next 8 px = FPS (255 max), msb first
                      00031 ;  RA1 = output segment 1
                      00032 ;  RA2 = output segment 2
                      00033 ;  RA3 = WS281X input stream
                      00034 ;        - first/second/third byte = segment 1/2/3 quad pixel length
                      00035 ;        - first segment data follows immediately
                      00036 ;  RA4 = output segment 4; receives anything after segment 1/2/3
                      00037 ;  RA5 = output segment 3
                      00038 ; TODO:
                      00039 ;  - use PPS to set RA3 as segment 3 out and RA5 as WS input?
                      00040 ;  - uart bootloader; ground segment 0 out to enable? auto-baud detect; verify
                      00041 ;  - custom pixel dup/skip, enforce max brightness limit?
                      00042 ;================================================================================
Message[301]: MESSAGE: (hoist 0: generic pic/asm helpers @2433)
Message[301]: MESSAGE: (TODO: fix this ^^^ vvv)
Message[301]: MESSAGE: (end of hoist 0 @2963)
Message[301]: MESSAGE: (no hoist, app config/defs @48)
                          M         exitm
                      00056 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00057 
MPASM 5.87  /HOME/DJ/MPLABXPROJECTS/VEEPROM-   2-19-2022  14:32:14         PAGE  2
PIC8-EEPROM - serial EEPROM emulator for 8-pin/8-bit Microchip PIC

LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00058 ;//compile-time options:
                      00059 ;#define BITBANG; //dev/test only
                      00060 ;;#define SPI_TEST
                      00061 #define WANT_DEBUG; //DEV/TEST ONLY!
                      00062 ;#define WANT_ISR; //ISR not used; uncomment to reserve space for ISR (or jump to)
                      00063 ;#define MAX_THREADS  2; //anim xmit or frame rcv, breakout xmit
                      00064 #define FOSC_FREQ  (32 MHz); //max speed; NOTE: SPI 3x requires max speed, otherwise lower speed might w
                            ork
                      00065 
                      00066 ;//pin assignments:
                      00067 ;#define WSDI  RA3; //RA3 = WS input stream (from controller or previous WS281X pixels)
                      00068 ;#define BREAKOUT  RA0; //RA0 = WS breakout pixels, or simple LED for dev/debug
                      00069 ;#define LEDOUT  IIFDEBUG(SEG4OUT, -1); //RA5 = simple LED output; ONLY FOR DEV/DEBUG
                      00070 ;#define WSCLK  4-2; //RA4 = WS input clock (recovered from WS input data signal); EUSART sync rcv clock
                             needs a real I/O pin?
                      00071 ;#define SEG1OUT  RA1; //RA1 = WS output segment 1
                      00072 ;#define SEG2OUT  RA2; //RA2 = WS output segment 2
                      00073 ;#define SEG3OUT  RA#v(3+2); //RA5 = WS output segment 3; RA3 is input-only, use alternate pin for segme
                            nt 3
                      00074 ;#define SEG4OUT  RA4; //RA4 = WS output segment 4
                      00075 ;;#define RGSWAP  0x321; //3 = R, 2 = G, 1 = B; default = 0x321 = RGB
                      00076 ;;#define RGSWAP  0x231; //3 = R, 2 = G, 1 = B; default = 0x321 = RGB
                      00077 ;#define RGB_ORDER  0x123; //R = byte[1-1], G = byte[2-1], B = byte[3-1]; default = 0x123 = RGB
                      00078 ;//             default    test strip
                      00079 ;//order 0x123: RGBYMCW => BRGMCYW
                      00080 ;//order 0x132: RGBYMCW => RBGMYCW
                      00081 ;//order 0x213: RGBYMCW => BGRCMYW
                      00082 ;//order 0x231: RGBYMCW => RGBYMCW ==
                      00083 ;//order 0x312: RGBYMCW => GBRCYMW
                      00084 ;//order 0x321: RGBYMCW => GRBYCMW
                      00085 ; messg [TODO] R is sending blue(3rd byte), G is sending red(first byte), B is sending green(second byte
                            )
                      00086 ;test strip is GRB order
                      00087 #define WANT_ISR  10; reserve space for small ISR
                      00088 
Message[301]: MESSAGE: (end of !hoist @88)
Message[301]: MESSAGE: (hoist 1: custom opc @655)
Message[301]: MESSAGE: ([INFO] COMPILED FOR DEV/DEBUG! @669)
  80000000                M ASM_MSB EQU -2147483648
Message[301]: MESSAGE: ([TODO]: need to UNLIT WREG_TRACKER when used in arith (else upper bits might be affected))
0000                      M init_0:
0000                      M     ORG 0
                          M     nop_multi 1
0000   0000               M     nop
  00000003                M _69COUNT = (((ASM_MSB | ((0 + 4) - $))) & ~ASM_MSB)
                          M     nop_multi 1
0001   0000               M     nop
                          M     nop_multi 1
0002   0000               M     nop
                          M     nop_multi 1
0003   0000               M     nop
000E                      M     ORG (0 + 4) + 10
Message[301]: MESSAGE: (end of hoist 1 @2429)
Message[301]: MESSAGE: (hoist 2: cooperative multi-tasking ukernel @117)
000E                      M     ORG ctx_addr_0
000E                      M init_1:
                      00561     iopin_init;
                          M     mov8 ANSELA, LITERAL(0); ; //all digital; CAUTION: do this before pin I/O
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
  0000                    M     LOCAL SRC = (ASM_MSB | (0)) ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM li
  1F38                    M     LOCAL DEST = ANSELA ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M     WARNIF(DEST == SRC, [WARNING] useless mov8 from ANSELA to (ASM_MSB | (0)) @1122);;
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @1123
                          M ;    messg src, dest @1124;
                          M     if ISLIT(SRC)  ;unpack SRC bytes
                          M ; messg dest, #v(!LIT2VAL(SRC)), #v(DEST != WREG), #v(!(DEST & INDF0_special)), #v(!(DEST & INDF1_special)) @1126
                          M         if !LIT2VAL(SRC) && (DEST != WREG) && !(DEST & INDF0_special) && !(DEST & INDF1_special)
                          M ;           BANKCHK dest;
                          M ;           BANKSAFE clrf dest; special case
                          M ;           EMIT CLRF dest;
                          M             CLRF ANSELA;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK ANSELA
000E   017E               M     banksel ANSELA
000F   01B8               M     clrf ANSELA
0010   3008               M     movlw (((ASM_MSB | ((1 << (RA3))))) & ~ASM_MSB)
0011   00B9               M     movwf WPUA
0012   0140               M     banksel LATA
0013   0198               M     clrf LATA
0014   0092               M     movwf TRISA
0015   0151               M     banksel OSCCON3
                          M     withbit_7 bcf OSCCON3
0016   138F               M     bcf OSCCON3, 7
0017   3060               M     movlw (((ASM_MSB | (b'110' << NOSC0 | 0 << NDIV0))) & ~ASM_MSB)
0018   008D               M     movwf OSCCON1
0019   3006               M     movlw (((ASM_MSB | (HFFRQ_32000000))) & ~ASM_MSB)
001A   0093               M     movwf OSCFRQ
001B   307B               M     movlw (((ASM_MSB | (0xFF ^ (1 << (SYSCMD)) ^ (1 << (NVMMD))))) & ~ASM_MSB)
001C   014F               M     banksel PMD0
001D   0096               M     movwf PMD0
001E   30F8               M     movlw (((ASM_MSB | (0xFF ^ (1 << (TMR2MD)) ^ (1 << (TMR1MD)) ^ (1 << (TMR0MD))))) & ~ASM_MSB)
001F   0097               M     movwf PMD1
0020   30FF               M     movlw (((ASM_MSB | (0xFF))) & ~ASM_MSB)
0021   0098               M     movwf PMD2
0022   0099               M     movwf PMD3
0023   009A               M     movwf PMD4
Message[301]: MESSAGE: (^v REINSTATE)
0024   009B               M     movwf PMD5
Message[301]: MESSAGE: ([TODO] use RSTOSC HFINT 1MHz? @601)
Message[301]: MESSAGE: ([TODO] boot loader + LVP? @620)
8007   178C           00632     __config _CONFIG1, MY_CONFIG1
8008   2FFE           00633     __config _CONFIG2, MY_CONFIG2
8009   3F9F           00634     __config _CONFIG3, MY_CONFIG3
800A   1FFF           00635     __config _CONFIG4, MY_CONFIG4
800B   3FFF           00636     __config _CONFIG5, MY_CONFIG5
Message[301]: MESSAGE: (end of hoist 2 @651)
Message[301]: MESSAGE: (hoist 5: custom main @95)
                          M         exitm
                      00098 ;; custom main ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00099 
                      00100     THREAD_DEF main, 6; 6 levels: wrapper->ws_player->drip->anim->ws_send->nop
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time
  00000070                M         stkptr_0 
                          M     ENDC  ;can't span macros
Message[301]: MESSAGE: (creating main thread# 0 @39, stack size 6, host stack remaining: 10 @170)
0025                      M     ORG ctx_addr_1
0025                      M init_2:
0025   3180               M     MOVLP ((stack_alloc_0) / 0x100)
0026   2030               M     call stack_alloc_0
0027   2036               M     call main
0028   282C               M     goto yield_again
0029   017F               M     banksel STKPTR
                          M     withdest_0 movf STKPTR
002A   086D               M     movf STKPTR, W;
002B   00F0               M     movwf stkptr_0
002F   0008               M     return
0030   017F               M     banksel STKPTR
                          M     withdest_0 movf STKPTR
0031   086D               M     movf STKPTR, W;
0032   00F0               M     movwf stkptr_0
0033   3005               M     movlw 6 - 1
                          M     withdest_1 addwf STKPTR
0034   07ED               M     addwf STKPTR, F;
                      00101 
                      00102 ;placeholder:
                      00103 ;real logic goes here
                      00104 main: DROP_CONTEXT;
                      00105     setbit LATA, RA0, TRUE;
0036   0140               M     banksel LATA
                          M     withbit_0 bsf LATA
0037   1418               M     bsf LATA, 0;
                      00106     setbit LATA, RA0, FALSE;
                          M     withbit_0 bcf LATA
0038   1018               M     bcf LATA, 0;
                      00107     GOTO main;
0039   2836               M     goto main
                      00108 
                      00109     THREAD_END;
                      00110 
Message[301]: MESSAGE: (end of hoist 5 @113)
Message[301]: MESSAGE: (epilog @2967)
0035                      M     ORG ctx_addr_3
0035   283A               M     goto init_3
003A                      M     ORG ctx_addr_4
003A                      M init_3:
003A                      M at_eof_0:
003A                      M at_eof_1:
003A                      M at_eof_2:
Message[301]: MESSAGE: ([INFO] optimization stats: @2955)
003A                      M at_eof_3:
Message[301]: MESSAGE: ([INFO] bank sel: 7 (39%), dropped: 11 (61%) @868)
003A                      M at_eof_4:
Message[301]: MESSAGE: ([INFO] non-banked used: 1/16 (6%) @1054)
003A                      M at_eof_5:
Message[301]: MESSAGE: ([INFO] (non-banked) Bit vars: allocated 0, used 0 @1806)
003A                      M at_eof_6:
Message[301]: MESSAGE: ([INFO] page sel: 1 (20%), dropped: 4 (80%) @2344)
Message[301]: MESSAGE: ([INFO] page0 used: 58/2048 (3%) @2346)
003A                      M at_eof_7:
003A                      M at_eof_8:
Message[301]: MESSAGE: ([INFO] #threads: 1, stack alloc: 6/16 (38%) @363)
Message[301]: MESSAGE: ([DEBUG] why is banksel needed here? 24 @369)
                          M     withdest_0 movf stkptr_1
003A   0870               M     movf stkptr_1, W;
003B   017F               M     banksel STKPTR
003C   00ED               M     movwf STKPTR
003D   0008               M     return
002C                      M     ORG ctx_addr_2
                          M     withdest_0 movf stkptr_1
002C   0870               M     movf stkptr_1, W;
002D   017F               M     banksel STKPTR
002E   00ED               M     movwf STKPTR
003E                      M     ORG ctx_addr_5
Message[301]: MESSAGE: (end of epilog @3003)
MPASM 5.87  /HOME/DJ/MPLABXPROJECTS/VEEPROM-   2-19-2022  14:32:14         PAGE  3
PIC8-EEPROM - serial EEPROM emulator for 8-pin/8-bit Microchip PIC

SYMBOL TABLE
  LABEL                             VALUE 

ABS                               IIF((x) < 0, -(x), x)
ADDLW                             addlw_tracker
ADDWF                             addwf_banksafe
ALIAS_DCL24                       
ALLOC_GPR                         
ANDLW                             andlw_tracker
ASM_MSB                           80000000
BANKCHK                           
BANKLEN                           0x80
BANKOF                            IIF(ISBANKED(reg), REG2ADDR(reg) / BANKLEN, BANK_UNKN)
BANKOFS                           ((reg) % BANKLEN)
BANKSAFE                          
BANKSEL_DROP                      0000000B
BANKSEL_KEEP                      00000009
BANK_TRACKER                      00001FED
BANK_UNKN                         -1
BCF                               bcf_tracker
BIT                               (1 << (n))
BITDCL                            
BITDCL_COUNT                      00000000
BITOF                             ((bitwrap) & 0x0F)
BITPARENT                         BITVARS#v(name / 8), 7 - name % 8
BITWRAP                           (((reg) << 4) | ((bitnum) & 0x0F))
BOOL2INT                          ((val) != 0)
BORROW                            STATUS, Carry, !
BSF                               bsf_tracker
BYTEOF                            IIF(ISLIT(val), BYTEOF_LIT(val, which), BYTEOF_REG(val, which))
BYTEOF_LIT                        LITERAL(((val) >> (8 * (which))) & 0xFF)
BYTEOF_REG                        REGISTER((val) + (which))
CALL                              call_pagesafe
CALLIF                            
CARRY                             STATUS, Carry,
CLRF                              clrf_tracker
CLRW                              CLRF WREG
COMMON_END                        0xC
CONTEXT_ADDR                      ctx_addr_#v(name)
CONTEXT_RESTORE                   
CONTEXT_SAVE                      
Carry                             00000000
DECF                              decf_banksafe
DECFSZ                            decfsz_tracker
DISABLED                          BIT(n)
DISABLED_ALL                      0xFF
DROP_BANK                         
DROP_CONTEXT                      
DROP_WREG                         
EMIT                              
EMITL                             
ENABLED                           NOBIT(n)
ENABLED_ALL                       0
ENDOF                             (name + SIZEOF(name))
EOF_ADDR                          0000003A
EOF_COUNT                         00000009
EQUALS0                           STATUS, Equals0,
ERRIF                             ERRIF_#v(((assert) != 0))  msg
ERRIF_0                           IGNORE_EOL
ERRIF_1                           error
EXPAND_CTL                        
EXPAND_POP                        EXPAND_CTL -1
EXPAND_PUSH                       EXPAND_CTL
EXPAND_RESTORE                    EXPAND_CTL 0xf00d
Equals0                           00000002
FALSE                             0
FOSC_FREQ                         (32 MHz)
FOUND_MSB                         00000000
FSR00hi                           00000005
FSR10hi                           00000007
GOTO                              goto_pagesafe
GPR_END                           0x70
GPR_START                         0x20
HIBYTE16                          BYTEOF(val, 1)
HIBYTE24                          BYTEOF(val, 2)
HOST_STKLEN                       16-0
IGNORE_EOL                        
IIF                               IIF_#v(((TF) != 0))(tval,  fval)
IIFDEBUG                          expr_true
IIF_0                             (fval)
IIF_1                             (tval)
INCF                              incf_banksafe
INCFSZ                            incfsz_tracker
INCW                              ADDLW 1
INDF0_postdec                     00020003
INDF0_postinc                     00020002
INDF0_predec                      00020001
INDF0_preinc                      00020000
INDF0_special                     00020000
INDF1_postdec                     00010003
INDF1_postinc                     00010002
INDF1_predec                      00010001
INDF1_preinc                      00010000
INDF1_special                     00010000
INIT_COUNT                        00000004
IN_THREAD                         00000000
IORLW                             iorlw_tracker
ISBANKED                          ((BANKOFS(reg) >= COMMON_END) && (BANKOFS(reg) < GPR_END))
ISLIT                             ((val) & ASM_MSB)
ISR_VECTOR                        (RESET_VECTOR + 4)
KHz                               * 1000
LAST_INIT                         00000040
LATEST_RAM1                       00000071
LINEAR                            (((reg) - GPR_START) | 0x2000)
LISTCTL                           
LIST_POP                          LISTCTL -1
LIST_PUSH                         LISTCTL
LIST_RESTORE                      LISTCTL 0xfeed
LIT2VAL                           ((n) & ~ASM_MSB)
LITBIT                            LITERAL(BIT(n))
LITERAL                           (ASM_MSB | (n))
LITPAGEOF                         ((addr) / LIT_PAGELEN)
LIT_PAGELEN                       0x800
LOBYTE                            BYTEOF(val, 0)
LODW                              
LSTCTL_DEEPEST                    00000003
LSTCTL_DEPTH                      00000000
LSTCTL_STACK                      00000000
MAX                               IIF((x) > (y), x, y)
MAX_RAM0                          00000070
MAX_RAM1                          000000F0
MAX_RAM9999                       00000080
MEXPAND_DEEPEST                   00000004
MEXPAND_DEPTH                     00000000
MEXPAND_STACK                     00000001
MHz                               * 1000000
MIDBYTE                           BYTEOF(val, 1)
MIN                               IIF((x) < (y), x, y)
MIN_STACK                         2
MIPS                              * 4 MHz
MOVF                              movf_banksafe
MOVIW_0_0                         MOVIW ++FSR0
MOVIW_0_1                         MOVIW --FSR0
MOVIW_0_2                         MOVIW FSR0++
MOVIW_0_3                         MOVIW FSR0--
MOVIW_1_0                         MOVIW ++FSR1
MOVIW_1_1                         MOVIW --FSR1
MOVIW_1_2                         MOVIW FSR1++
MOVIW_1_3                         MOVIW FSR1--
MOVIW_opc                         MOVIW_#v((fsr) == FSR1)_#v((mode) & 3)
MOVLW                             movlw_tracker
MOVWF                             movwf_banksafe
MOVWI_0_0                         MOVWI ++FSR0
MOVWI_0_1                         MOVWI --FSR0
MOVWI_0_2                         MOVWI FSR0++
MOVWI_0_3                         MOVWI FSR0--
MOVWI_1_0                         MOVWI ++FSR1
MOVWI_1_1                         MOVWI --FSR1
MOVWI_1_2                         MOVWI FSR1++
MOVWI_1_3                         MOVWI FSR1--
MOVWI_opc                         MOVWI_#v((fsr) == FSR1)_#v((mode) & 3)
MY_CONFIG1                        0000178C
MY_CONFIG2                        00002FFE
MY_CONFIG3                        00003F9F
MY_CONFIG4                        00001FFF
MY_CONFIG5                        00003FFF
NEEDS_BANKSEL                     (ISBANKED(regto) && (BANKOF(regto) != BANKOF(regfrom)))
NEXT_RAM0                         00000020
NEXT_RAM1                         000000A0
NEXT_RAM9999                      00000071
NOBANK                            0000270F
NOBIT                             0
NOP                               nop_multi
NOP_expanded                      00000000
NULL_STMT                         ORG $
NUM_CONTEXT                       00000007
NUM_THREADS                       00000001
NVMADR0hi                         0000081B
NVMDAT0hi                         0000081D
PAGECHK                           
PAGESEL_DROP                      00000004
PAGESEL_KEEP                      00000001
PAGE_TRACKER                      00000036
PASS1_FIXUPS                      00000000
PASS2_FIXUPS                      00000000
PLL                               * 2
POP                               
PUSH                              
RAM_BLOCK                         00000001
RAM_LEN0                          00000050
RAM_LEN1                          00000050
RAM_LEN9999                       00000010
RAM_START0                        00000020
RAM_START1                        000000A0
RAM_START9999                     00000070
RAM_USED0                         00000000
RAM_USED1                         00000000
RAM_USED9999                      00000001
REG2ADDR                          (a)
REGHI                             name#v(0)hi
REGISTER                          (a)
REGLO                             name
REGMID                            name#v(0)mid
REGOF                             (((bitwrap) >> 4) & 0xFFFF)
REGPAGEOF                         ((addr) / REG_PAGELEN)
REG_PAGELEN                       0x100
REPEAT                            
REPEATER                          00000003
RERUN_THREADS                     TRUE
RESERVE                           ORG$+n
RESET_VECTOR                      0
REVBIT                            (0x80 >> (n))
SET8W                             IORLW 0xFF
SIZEOF                            name#v(0)size
SP1BRG0hi                         0000011C
STK_ALLOC                         00000006
SUBLW                             sublw_tracker
SUBLWB                            
SUPPORTED                         TRUE
SWAPF                             swapf_banksafe
THREAD_DEF                        
THREAD_END                        
TOS                               00001FEE
TOS0hi                            00001FEF
TRUE                              1
UGLY_PASS12FIX                    
USE_HFFRQ                         b'110'
WANT_DEBUG                        
WANT_ISR                          10
WARNIF                            WARNIF_#v(((assert) != 0))  msg
WARNIF_0                          IGNORE_EOL
WARNIF_1                          messg
WREG_TRACKER                      00000070
WREG_UNKN                         40000000
XBIT                              NOBIT(n)
XORLW                             xorlw_tracker
YESNO                             YESNO_#v(((val) != 0))
YESNO_0                           false
YESNO_1                           true
YIELD_AGAIN_inlined               
__16F15313                        00000001
__DEBUG                           
__MPLAB_DEBUGGER_SIMULATOR        1
addlw_tracker                     
addwf_banksafe                    
andlw_tracker                     
asmbit                            00000020
asmpower2                         00000000
at_eof                            
b0DCL                             ALLOC_GPR 0,
b0DCL16                           
b0DCL24                           
b0DCL8                            
b1DCL                             ALLOC_GPR 1,
bcf_tracker                       
before_yield                      00000005
bitnum_arg                        withbit_#v(argg)
bitoff_0                          
bitoff_1                          
bitoff_2                          
bitoff_3                          
bitoff_4                          
bitoff_5                          
bitoff_6                          
bitoff_7                          
biton_0                           
biton_1                           
biton_2                           
biton_3                           
biton_4                           
biton_5                           
biton_6                           
biton_7                           
bsf_tracker                       
call_pagesafe                     
clrf_tracker                      
clrw                              clrf WREG
comf2s                            
dec16                             
decf_banksafe                     
decfsz_tracker                    
dest_arg                          withdest_#v(argg)
divup                             (((num)+(den)-1)/(den))
doing_init                        
eof                               0000003A
eof_0                             
eof_1                             
eof_2                             
eof_3                             
eof_4                             
eof_5                             
eof_6                             
eof_7                             
eof_8                             
find_msb                          
fosc_init                         
goto_pagesafe                     
ifbit                             
ifbit_const                       
inc16                             
incf_banksafe                     
incfsz_tracker                    
incw                              addlw 1
iopin_init                        
iorlw_tracker                     
khz                               rdiv(freq, 1000)
log2                              LOG2_#v(n)
main                              00000036
mhz                               rdiv(freq, 1000000)
mov16                             mov_mb 16,
mov24                             mov_mb 24,
mov8                              
mov_mb                            
movf_banksafe                     
movlw_tracker                     
movwf_banksafe                    
msec                              * 1000
nbDCL                             ALLOC_GPR NOBANK,
nbDCL16                           
nbDCL24                           
nbDCL8                            
nop_multi                         
nopif                             
pct                               rdiv(100 * (num), den)
pmd_init                          
pps_lock                          
prescaler                         log2((base_freq) / (want_freq))
rdiv                              (((num)+(den)/2)/MAX(den, 1))
scale                             (BIT(prescale) KHz / khz(freq))
sec                               * 1000000
setbit                            
showarg_0                         
stkptr_00size                     00000001
sublw_tracker                     
swapf_banksafe                    
swapreg                           
usec                              * 1
val_arg                           showarg_#v(argg)
whilebit                          
with_arg                          witharg_#v(argg)
witharg_0                         
withbit_0                         
withbit_1                         
withbit_2                         
withbit_3                         
withbit_4                         
withbit_5                         
withbit_6                         
withbit_7                         
withdest_0                        
withdest_1                        
xorlw_tracker                     
yield                             00000029
yield_again                       0000002C


MEMORY USAGE MAP ('X' = Used,  '-' = Unused)

0000 : XXXX----------XX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXX-
8000 : -------XXXXX---- ---------------- ---------------- ----------------

All other memory blocks unused.

Program Memory Words Used:    58
Program Memory Words Free:  1990


Errors   :     0
Warnings :     0 reported,     0 suppressed
Messages :    27 reported,    16 suppressed


